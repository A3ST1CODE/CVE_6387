import { NextResponse } from "next/server";
import net from "net";
import { lookup } from "dns";
import CIDR from "ip-cidr";
import path from "path";
import fs from "fs";
import { getCache, setCache } from "../../../utils/cache";

async function createSocket(ip, port, timeout) {
	return new Promise((resolve) => {
		const sock = net.createConnection(port, ip, () => resolve(sock));
		sock.setTimeout(timeout * 1000);
		sock.on("timeout", () => {
			sock.destroy();
			resolve(null);
		});
		sock.on("error", (err) => {
			console.error(`Socket error for ${ip}:${port}`, err);
			resolve(
				err.code === "ECONNREFUSED"
					? {
							status: false,
							message: `Connection refused for ${ip}:${port}`,
					  }
					: null
			);
		});
	});
}

async function getSshBanner(sock, useHelpRequest) {
	return new Promise((resolve) => {
		sock.setTimeout(1000);
		let banner = "";
		sock.on("data", (data) => {
			banner += data.toString().trim();
			if (banner || !useHelpRequest) {
				resolve(banner);
			} else {
				const helpString = "HELP\n";
				sock.write(helpString);
				sock.once("data", (data) => resolve(data.toString().trim()));
			}
		});
		sock.on("error", (e) => {
			console.error("Error receiving SSH banner", e);
			resolve(e.message);
		});
	});
}

async function resolveIp(target) {
	return new Promise((resolve) => {
		lookup(target, (err, address) => {
			if (err) {
				console.error(`DNS resolve error for ${target}`, err);
				resolve(null);
			} else {
				resolve(address);
			}
		});
	});
}

async function checkVulnerability(
	ip,
	port,
	timeout,
	graceTimeCheck,
	useHelpRequest,
	dnsResolve
) {
	const cacheKey = `${ip}:${port}`;
	const cachedData = await getCache(cacheKey);
	if (cachedData) {
		console.log(`Cache hit for ${cacheKey}`);
		return {
			status: true,
			msg: "Berhasil ambil data dari cache",
			data: cachedData,
		};
	}

	console.log(`Checking vulnerability for ${ip}:${port}`);
	const sshsock = await createSocket(ip, port, timeout);
	if (!sshsock || sshsock.status === false) {
		const result = {
			status: true,
			msg: "Berhasil mendapatkan data!",
			data: {
				ip,
				port,
				status: "closed",
				message: sshsock ? sshsock.message : "Port closed",
				hostname: ip,
				type: "1",
			},
		};
		await setCache(cacheKey, result.data); // Cache the result
		return result;
	}

	const banner = await getSshBanner(sshsock, useHelpRequest);
	console.log(`Received banner: ${banner}`);
	if (!banner.includes("SSH-2.0")) {
		const result = {
			status: true,
			msg: "Berhasil mendapatkan data!",
			data: {
				ip,
				port,
				status: "failed",
				message: [`Failed to retrieve SSH banner: ${banner}`],
				hostname: ip,
				type: "2",
			},
		};
		await setCache(cacheKey, result.data); // Cache the result
		return result;
	}

	if (!banner.includes("SSH-2.0-OpenSSH")) {
		const result = {
			status: true,
			msg: "Berhasil mendapatkan data!",
			data: {
				ip,
				port,
				status: "unknown",
				message: `(banner: ${banner})`,
				hostname: ip,
				type: "3",
			},
		};
		await setCache(cacheKey, result.data); // Cache the result
		return result;
	}

	const hostname = dnsResolve ? await resolveIp(ip) : null;
	const { vulnerableVersions, patchedVersions } = JSON.parse(
		fs.readFileSync(path.join(process.cwd(), "patch.json"), "utf8")
	);
	const result =
		vulnerableVersions.some((version) => banner.includes(version)) &&
		!patchedVersions.includes(banner)
			? {
					status: true,
					msg: "Berhasil mendapatkan data!",
					data: {
						ip,
						port,
						status: "vulnerable",
						message: `(running ${banner})`,
						hostname,
						type: "4",
					},
			  }
			: {
					status: true,
					msg: "Berhasil mendapatkan data!",
					data: {
						ip,
						port,
						status: "not_vulnerable",
						message: `(running ${banner})`,
						hostname,
						type: "5",
					},
			  };

	await setCache(cacheKey, result.data); // Cache the result
	return result;
}

async function checkVulnerabilityWithTimeout(
	ip,
	port,
	timeout = 30,
	graceTimeCheck,
	useHelpRequest,
	dnsResolve
) {
	try {
		return await Promise.race([
			checkVulnerability(
				ip,
				port,
				timeout,
				graceTimeCheck,
				useHelpRequest,
				dnsResolve
			),
			new Promise((_, reject) =>
				setTimeout(
					() => reject(new Error("Check timed out")),
					timeout * 1000
				)
			),
		]);
	} catch (error) {
		console.error(`Error checking vulnerability for ${ip}:${port}`, error);
		return {
			status: true,
			msg: "Berhasil mendapatkan data!",
			data: {
				ip,
				port,
				status: "failed",
				message: [`Failed to retrieve SSH banner: ${error.message}`],
				hostname: ip,
				type: "2",
			},
		};
	}
}

export async function POST(req) {
	try {
		const {
			targets,
			ports,
			timeout = 5,
			graceTimeCheck,
			useHelpRequest,
			dnsResolve,
		} = await req.json();
		console.log("Received data from client:", {
			targets,
			ports,
			timeout,
			graceTimeCheck,
			useHelpRequest,
			dnsResolve,
		});

		const resultQueue = [];
		const batchSize = 10;
		const cidrTargets = [];

		for (const target of targets) {
			if (CIDR.isValidCIDR(target)) {
				const cidr = new CIDR(target);
				cidrTargets.push(...cidr.toArray());
			} else if (net.isIP(target)) {
				cidrTargets.push(target);
			} else {
				const resolvedIp = await resolveIp(target);
				if (resolvedIp) {
					cidrTargets.push(resolvedIp);
				} else {
					console.error(`Invalid target: ${target}`);
				}
			}
		}

		for (let i = 0; i < cidrTargets.length; i += batchSize) {
			const batchTargets = cidrTargets.slice(i, i + batchSize);
			const promises = batchTargets.flatMap((target) =>
				ports.map((port) =>
					checkVulnerabilityWithTimeout(
						target,
						port,
						timeout,
						graceTimeCheck,
						useHelpRequest,
						dnsResolve
					)
						.then((result) => resultQueue.push(result))
						.catch((error) => {
							console.error(
								`Error checking vulnerability for ${target}:${port}`,
								error
							);
							const result = {
								status: true,
								msg: "Berhasil mendapatkan data!",
								data: {
									ip: target,
									port,
									status: "failed",
									message: [
										`Failed to retrieve SSH banner: ${error.message}`,
									],
									hostname: target,
									type: "2",
								},
							};
							resultQueue.push(result);
						})
				)
			);
			await Promise.all(promises);
			console.log(`Batch ${i / batchSize + 1} processed`);
		}

		const groupedResults = resultQueue.reduce((acc, result) => {
			const key = `${result.msg}`;
			if (!acc[key]) {
				acc[key] = {
					status: result.status,
					msg: result.msg,
					data: [],
				};
			}
			acc[key].data.push(result.data);
			return acc;
		}, {});

		const finalResults = Object.values(groupedResults);
		console.log("Results:", finalResults);
		return NextResponse.json(finalResults);
	} catch (error) {
		console.error("Error processing request", error);
		return NextResponse.json(
			{
				error: "Failed to process request",
			},
			{
				status: 500,
			}
		);
	}
}
